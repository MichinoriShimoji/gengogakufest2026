<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Surprisal Calculator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Sans+JP:wght@400;500;600&display=swap');

  :root {
    --bg: #1a1a1e; --bg2: #222226; --bg3: #2a2a30;
    --fg: #e0ddd8; --dim: #888; --muted: #666;
    --bdr: #3a3a40; --bdr2: #2e2e34;
    --red: #e25850; --blu: #5b8def; --pur: #a577d0;
    --grn: #6bc26b; --gld: #d4a830;
    --mono: 'IBM Plex Mono', monospace;
    --sans: 'IBM Plex Sans', 'IBM Plex Sans JP', sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--sans); background: var(--bg); color: var(--fg);
    line-height: 1.5; min-height: 100vh;
  }

  .container { max-width: 900px; margin: 0 auto; padding: 24px 20px; }

  h1 {
    font-size: 22px; font-weight: 700; letter-spacing: -0.5px;
    margin-bottom: 4px;
  }
  h1 span { color: var(--gld); }
  .sub { color: var(--dim); font-size: 13px; margin-bottom: 24px; }

  /* â”€â”€ Upload Zone â”€â”€ */
  .upload-zone {
    border: 2px dashed var(--bdr); border-radius: 10px;
    padding: 40px 20px; text-align: center; cursor: pointer;
    transition: all .2s; background: var(--bg2); margin-bottom: 20px;
  }
  .upload-zone:hover, .upload-zone.dragover {
    border-color: var(--gld); background: rgba(212,168,48,.06);
  }
  .upload-zone .icon { font-size: 32px; margin-bottom: 8px; opacity: .7; }
  .upload-zone p { color: var(--dim); font-size: 14px; }
  .upload-zone p strong { color: var(--gld); }
  .upload-zone input { display: none; }

  /* â”€â”€ Settings â”€â”€ */
  .settings {
    display: flex; gap: 16px; flex-wrap: wrap; align-items: end;
    margin-bottom: 20px;
  }
  .field { display: flex; flex-direction: column; gap: 4px; }
  .field label { font-size: 11px; color: var(--dim); font-weight: 600; text-transform: uppercase; letter-spacing: .5px; }
  .field input, .field select {
    font-family: var(--mono); font-size: 13px; padding: 6px 10px;
    background: var(--bg3); border: 1px solid var(--bdr); border-radius: 5px;
    color: var(--fg); outline: none; min-width: 100px;
  }
  .field input:focus { border-color: var(--gld); }

  .btn {
    font-family: var(--sans); font-size: 13px; font-weight: 600;
    padding: 7px 20px; border: none; border-radius: 5px; cursor: pointer;
    background: var(--gld); color: var(--bg); transition: opacity .15s;
  }
  .btn:hover { opacity: .85; }
  .btn:disabled { opacity: .4; cursor: not-allowed; }

  /* â”€â”€ Status â”€â”€ */
  .status {
    font-family: var(--mono); font-size: 12px; color: var(--dim);
    padding: 8px 12px; background: var(--bg2); border-radius: 6px;
    margin-bottom: 16px; display: none; border-left: 3px solid var(--gld);
  }
  .status.error { border-left-color: var(--red); color: var(--red); }
  .status.ok { border-left-color: var(--grn); }

  /* â”€â”€ Results â”€â”€ */
  .results { display: none; }

  .summary {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 12px; margin-bottom: 24px;
  }
  .stat-card {
    background: var(--bg2); border: 1px solid var(--bdr); border-radius: 8px;
    padding: 14px 16px;
  }
  .stat-card .label { font-size: 11px; color: var(--dim); text-transform: uppercase; letter-spacing: .5px; margin-bottom: 4px; }
  .stat-card .value { font-family: var(--mono); font-size: 20px; font-weight: 600; }

  .target-section { margin-bottom: 28px; }
  .target-header {
    display: flex; align-items: baseline; gap: 12px;
    margin-bottom: 10px; padding-bottom: 6px; border-bottom: 1px solid var(--bdr);
  }
  .target-name { font-size: 18px; font-weight: 700; }
  .target-meta { font-size: 12px; color: var(--dim); font-family: var(--mono); }

  table {
    width: 100%; border-collapse: collapse; font-size: 13px;
    margin-bottom: 8px;
  }
  th {
    text-align: left; font-size: 11px; color: var(--dim);
    text-transform: uppercase; letter-spacing: .5px;
    padding: 6px 10px; border-bottom: 1px solid var(--bdr);
    font-weight: 600;
  }
  th.r, td.r { text-align: right; }
  td {
    padding: 5px 10px; font-family: var(--mono); font-size: 12px;
    border-bottom: 1px solid var(--bdr2);
  }
  tr.hl { background: rgba(226,88,80,.08); }
  tr.hl td:first-child { font-weight: 600; color: var(--red); }
  tr:hover { background: rgba(255,255,255,.03); }

  .sig { color: var(--grn); font-weight: 600; }
  .ns { color: var(--muted); }
  .pos { color: var(--red); }
  .neg { color: var(--blu); }

  /* â”€â”€ Chart â”€â”€ */
  .chart-wrap {
    background: var(--bg2); border: 1px solid var(--bdr); border-radius: 8px;
    padding: 16px; margin-top: 12px;
  }
  .chart-wrap h3 { font-size: 13px; color: var(--dim); margin-bottom: 12px; }

  /* â”€â”€ Footer â”€â”€ */
  .methodology {
    margin-top: 32px; padding: 16px; background: var(--bg2);
    border: 1px solid var(--bdr); border-radius: 8px; font-size: 12px;
    color: var(--dim); line-height: 1.7;
  }
  .methodology h3 { font-size: 13px; color: var(--fg); margin-bottom: 8px; }
  .methodology code { font-family: var(--mono); color: var(--gld); font-size: 11px; }

  @media (max-width: 600px) {
    .summary { grid-template-columns: 1fr 1fr; }
    .settings { flex-direction: column; }
  }
</style>
</head>
<body>
<div class="container">

  <h1>Bigram <span>Surprisal</span> Calculator</h1>
  <p class="sub">JSON ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ â†’ ãƒã‚¤ã‚°ãƒ©ãƒ ãƒ»ã‚µãƒ—ãƒ©ã‚¤ã‚¶ãƒ«ã‚’è¨ˆç®—ï¼ˆmorph|gloss æŒ‡å®šå¯¾å¿œï¼‰</p>

  <!-- Upload -->
  <div class="upload-zone" id="dropZone">
    <div class="icon">ğŸ“‚</div>
    <p><strong>JSON ã‚’ãƒ‰ãƒ­ãƒƒãƒ—</strong>ã€€ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ</p>
    <input type="file" id="fileInput" accept=".json">
  </div>

  <!-- Settings -->
  <div class="settings">
    <div class="field">
      <label>Î± (smoothing)</label>
      <input type="number" id="alpha" value="0.01" step="0.001" min="0">
    </div>
    <div class="field">
      <label>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª (ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š, morph|gloss å¯)</label>
      <input type="text" id="targets" value="mmja, unu, naugara" style="min-width:260px;" placeholder="mmja, TOP, a|TOP, V[SEQ]">
    </div>
    <div class="field">
      <label>ã‚ªãƒ•ã‚»ãƒƒãƒˆç¯„å›²</label>
      <div style="display:flex;gap:4px;">
        <input type="number" id="offFrom" value="-5" style="min-width:55px;width:55px;">
        <span style="color:var(--dim);line-height:32px;">ã€œ</span>
        <input type="number" id="offTo" value="5" style="min-width:55px;width:55px;">
      </div>
    </div>
    <button class="btn" id="runBtn" disabled>è¨ˆç®—å®Ÿè¡Œ</button>
  </div>

  <div class="status" id="status"></div>

  <!-- Results -->
  <div class="results" id="results">
    <div class="summary" id="summaryCards"></div>
    <div id="targetResults"></div>
    
    <div class="methodology">
      <h3>æ–¹æ³•è«–</h3>
      <p>
        1. <code>word_unit_id</code> ã§èªãƒ¬ãƒ™ãƒ«ã«æŠ˜ã‚Šç•³ã¿ï¼ˆç™ºè©±å˜ä½ã§ä¸€æ„åŒ–ã€å…ˆé ­å½¢æ…‹ç´ ï¼èªãƒˆãƒ¼ã‚¯ãƒ³ã€å¢ƒç•Œã¯èªã‚°ãƒ«ãƒ¼ãƒ—å†…ã‹ã‚‰ä¼æ’­ï¼‰<br>
        2. Add-Î± smoothing ä»˜ããƒã‚¤ã‚°ãƒ©ãƒ ãƒ¢ãƒ‡ãƒ«: <code>P(w|c) = (count(c,w)+Î±) / (count(c)+Î±V)</code><br>
        3. ç¯€å¢ƒç•Œãƒªã‚»ãƒƒãƒˆ: <code>EOS / EAC / EQC / Q</code> â†’ æ¬¡ã®èªã®æ–‡è„ˆã‚’ <code>&lt;BOS&gt;</code> ã«<br>
        4. ã‚µãƒ—ãƒ©ã‚¤ã‚¶ãƒ«: <code>S(w|c) = âˆ’logâ‚‚ P(w|c)</code><br>
        5. Cohen's d = (ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå¹³å‡ âˆ’ ã‚³ãƒ¼ãƒ‘ã‚¹å¹³å‡) / ã‚³ãƒ¼ãƒ‘ã‚¹SD<br>
        6. Wilcoxon signed-rank testï¼ˆBonferroni k=ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ•° ã§è£œæ­£ï¼‰
      </p>
      <p style="margin-top:10px;">
        <strong>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæŒ‡å®š:</strong>
        <code>mmja</code>ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®šç¾©ï¼‰ã€
        <code>TOP</code>ï¼ˆå¤§æ–‡å­—ã®ã¿â†’glossæŒ‡å®šã€å…¨ç•°å½¢æ…‹ a/ja/naâ€¦ ã‚’åˆç®—ï¼‰ã€
        <code>a|TOP</code>ï¼ˆmorph=a, gloss=TOP ã«é™å®šï¼‰ã€
        <code>V[SEQ]</code>ï¼ˆword_pos=V ã§èªæœ«å½¢æ…‹ç´ ã® gloss=SEQï¼‰ã€
        <code>[PST]</code>ï¼ˆposä¸å•ã€èªæœ«ãŒ PST ã®èªã™ã¹ã¦ï¼‰ã€‚
        èªãƒ¬ãƒ™ãƒ«åˆ†æã®ãŸã‚å…ˆé ­å½¢æ…‹ç´ ã®ã¿ãŒãƒãƒƒãƒå¯¾è±¡ï¼ˆgloss ã¯å…ˆé ­å½¢æ…‹ç´ ã€tail_gloss ã¯æœ«å°¾å½¢æ…‹ç´ ï¼‰ã€‚
      </p>
    </div>
  </div>

</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Core Surprisal Engine (pure JS, mirrors surprisal_calc.py)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CLAUSE_BOUNDARIES = new Set(['EOS','EAC','EQC','Q','EQC+EOS','EQC+Q']);

function loadAndCollapse(data) {
  const flat = [];
  for (let ui = 0; ui < data.length; ui++) {
    const utt = data[ui];
    const n = utt.morphs.length;
    for (let i = 0; i < n; i++) {
      flat.push({
        morph:        utt.morphs[i],
        pos:          utt.pos[i],
        gloss:        utt.gloss[i],
        boundary:     utt.boundary[i],
        sentence_id:  utt.sentence_id[i],
        word_unit_id: utt.word_unit_id[i],
        word_pos:     utt.word_pos[i],
        _uttIdx:      ui,
      });
    }
  }

  const wordSents = new Map(); // sentence_id â†’ [{...}, ...]
  // word_unit_id ã¯ç™ºè©±å†…ã§ã®ã¿ä¸€æ„ã€‚(_uttIdx, word_unit_id) ã‚’ã‚­ãƒ¼ã«ã™ã‚‹ã€‚
  let curKey = null, curGroup = [];

  function flush() {
    if (!curGroup.length) return;
    const wt = {...curGroup[0]};
    wt.boundary = null;
    for (const m of curGroup) {
      if (m.boundary) wt.boundary = m.boundary;
    }
    wt.tail_gloss = curGroup[curGroup.length - 1].gloss;
    delete wt._uttIdx;
    const sid = wt.sentence_id;
    if (!wordSents.has(sid)) wordSents.set(sid, []);
    wordSents.get(sid).push(wt);
  }

  for (const m of flat) {
    const key = m._uttIdx + ',' + m.word_unit_id;
    if (key !== curKey) {
      flush();
      curGroup = [m];
      curKey = key;
    } else {
      curGroup.push(m);
    }
  }
  flush();
  return wordSents;
}

function isClauseBoundary(w) {
  return w.boundary ? CLAUSE_BOUNDARIES.has(w.boundary) : false;
}

function buildBigramModel(wordSents, alpha) {
  const mc = new Map(); // unigram
  const bc = new Map(); // bigram "prev\0cur" â†’ count
  const cc = new Map(); // context count

  const inc = (map, key) => map.set(key, (map.get(key)||0) + 1);
  const bk = (p,c) => p + '\0' + c;

  const sids = [...wordSents.keys()].sort((a,b) => a-b);
  for (const sid of sids) {
    let prev = '<BOS>';
    for (const w of wordSents.get(sid)) {
      const cur = w.morph.toLowerCase();
      inc(mc, cur);
      inc(bc, bk(prev, cur));
      inc(cc, prev);
      prev = isClauseBoundary(w) ? '<BOS>' : cur;
    }
    inc(bc, bk(prev, '<EOS>'));
    inc(cc, prev);
  }

  const V = mc.size;
  const T = [...mc.values()].reduce((a,b) => a+b, 0);

  function surp(p, c) {
    const ctx = cc.get(p) || 0;
    if (ctx === 0) {
      return -Math.log2(((mc.get(c)||0) + alpha) / (T + alpha * V));
    }
    return -Math.log2(((bc.get(bk(p,c))||0) + alpha) / (ctx + alpha * V));
  }

  return { surp, mc, V, T };
}

function computeAllSurprisals(wordSents, surpFn) {
  const allSurp = [];
  const wordIndex = [];
  const lookup = new Map();

  const sids = [...wordSents.keys()].sort((a,b) => a-b);
  for (const sid of sids) {
    let prev = '<BOS>';
    const ws = wordSents.get(sid);
    for (let wi = 0; wi < ws.length; wi++) {
      const w = ws[wi];
      const cur = w.morph.toLowerCase();
      allSurp.push(surpFn(prev, cur));
      wordIndex.push({ sid, wi, w });
      lookup.set(sid + ',' + wi, allSurp.length - 1);
      prev = isClauseBoundary(w) ? '<BOS>' : cur;
    }
  }
  return { allSurp, wordIndex, lookup };
}

// Parse target specification: "morph", "morph|gloss", "|gloss", or "morph|gloss|pos"
function parseTargetSpec(spec) {
  const parts = spec.split('|');
  const morph = parts[0] ? parts[0].toLowerCase() : null;  // empty â†’ null
  const gloss = parts.length > 1 && parts[1] ? parts[1] : null;
  const pos   = parts.length > 2 && parts[2] ? parts[2] : null;
  return { morph, gloss, pos, raw: spec };
}

// Built-in defaults (used when no | is present and name matches)
const DEFAULT_TARGETS = {
  mmja:    w => w.morph.toLowerCase() === 'mmja'    && w.word_pos === 'INTJ',
  unu:     w => w.morph.toLowerCase() === 'unu'     && w.word_pos === 'INTJ',
  naugara: w => {
    const m = w.morph.toLowerCase();
    return (m === 'naugara' || m === 'nautiga') && w.word_pos === 'INTJ';
  },
};

const BRACKET_RE = /^([A-Za-z]*)\[([^\]]+)\]$/;

function findTargets(wordIndex, nameOrSpec) {
  let matchFn;
  const bm = nameOrSpec.match(BRACKET_RE);
  if (bm) {
    // POS[TAIL_GLOSS] å½¢å¼: V[SEQ], [SEQ], etc.
    const posP = bm[1] || null;
    const tailP = bm[2];
    matchFn = w => {
      if (posP && w.word_pos !== posP) return false;
      return w.tail_gloss === tailP;
    };
  } else if (nameOrSpec.includes('|')) {
    // morph|gloss or morph|gloss|pos (morph can be empty: "|TOP")
    const { morph, gloss, pos } = parseTargetSpec(nameOrSpec);
    matchFn = w => {
      if (morph && w.morph.toLowerCase() !== morph) return false;
      if (gloss && w.gloss !== gloss) return false;
      if (pos && w.word_pos !== pos) return false;
      return true;
    };
  } else {
    const ml = nameOrSpec.toLowerCase();
    if (DEFAULT_TARGETS[ml]) {
      matchFn = DEFAULT_TARGETS[ml];
    } else if (/^[A-Z0-9]+$/.test(nameOrSpec)) {
      // å¤§æ–‡å­—ã®ã¿ â†’ gloss æŒ‡å®šï¼ˆå…¨ç•°å½¢æ…‹ï¼‰
      const g = nameOrSpec;
      matchFn = w => w.gloss === g;
    } else {
      matchFn = w => w.morph.toLowerCase() === ml;
    }
  }
  return wordIndex
    .map((item, ai) => ({ ...item, ai }))
    .filter(({ w }) => matchFn(w))
    .map(({ sid, wi }) => [sid, wi]);
}

function getOffsetValues(locs, offset, allSurp, lookup) {
  const vals = [];
  for (const [sid, wi] of locs) {
    const key = sid + ',' + (wi + offset);
    if (lookup.has(key)) vals.push(allSurp[lookup.get(key)]);
  }
  return vals;
}

// Wilcoxon signed-rank test (simplified, two-sided)
function wilcoxonTest(values, mu) {
  const diffs = values.map(v => v - mu).filter(d => d !== 0);
  const n = diffs.length;
  if (n < 10) return { stat: null, p: null };

  const ranked = diffs.map(d => ({ d, abs: Math.abs(d) }))
    .sort((a,b) => a.abs - b.abs);

  // Assign ranks with tie averaging
  for (let i = 0; i < ranked.length; ) {
    let j = i;
    while (j < ranked.length && ranked[j].abs === ranked[i].abs) j++;
    const avgRank = (i + j + 1) / 2; // 1-based
    for (let k = i; k < j; k++) ranked[k].rank = avgRank;
    i = j;
  }

  const Wplus = ranked.filter(r => r.d > 0).reduce((s, r) => s + r.rank, 0);
  const Wminus = ranked.filter(r => r.d < 0).reduce((s, r) => s + r.rank, 0);
  const W = Math.min(Wplus, Wminus);

  // Normal approximation
  const meanW = n * (n + 1) / 4;
  const sdW = Math.sqrt(n * (n + 1) * (2 * n + 1) / 24);
  const z = (W - meanW) / sdW;
  // Two-sided p-value from normal approximation
  const p = 2 * normalCDF(z);

  return { stat: W, p, z };
}

function normalCDF(x) {
  // Abramowitz & Stegun approximation
  const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
  const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x) / Math.SQRT2;
  const t = 1.0 / (1.0 + p * x);
  const y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t * Math.exp(-x*x);
  return 0.5 * (1.0 + sign * y);
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let loadedData = null;

const $  = id => document.getElementById(id);
const dropZone = $('dropZone');
const fileInput = $('fileInput');
const runBtn = $('runBtn');
const statusEl = $('status');
const resultsEl = $('results');

// File handling
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault(); dropZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', () => { if (fileInput.files.length) handleFile(fileInput.files[0]); });

function handleFile(file) {
  showStatus(`èª­ã¿è¾¼ã¿ä¸­: ${file.name} (${(file.size/1024).toFixed(0)} KB)...`);
  const reader = new FileReader();
  reader.onload = e => {
    try {
      loadedData = JSON.parse(e.target.result);
      if (!Array.isArray(loadedData) || !loadedData[0]?.morphs) throw new Error('Invalid format');
      const nUtt = loadedData.length;
      const nMorph = loadedData.reduce((s, u) => s + u.morphs.length, 0);
      dropZone.querySelector('p').innerHTML = `<strong>âœ“ ${file.name}</strong>ã€€${nUtt} ç™ºè©±ãƒ»${nMorph} å½¢æ…‹ç´ `;
      showStatus(`${file.name} ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼ˆ${nUtt} ç™ºè©±ï¼‰`, 'ok');
      runBtn.disabled = false;
    } catch (err) {
      showStatus('Error: JSONã®å½¢å¼ãŒä¸æ­£ã§ã™ â€” ' + err.message, 'error');
      loadedData = null;
      runBtn.disabled = true;
    }
  };
  reader.readAsText(file);
}

function showStatus(msg, type='') {
  statusEl.textContent = msg;
  statusEl.className = 'status' + (type ? ' ' + type : '');
  statusEl.style.display = 'block';
}

// Run
runBtn.addEventListener('click', run);

function run() {
  if (!loadedData) return;
  const alpha = parseFloat($('alpha').value) || 0.01;
  const targetNames = $('targets').value.split(/[,ã€\s]+/).map(s => s.trim()).filter(Boolean);
  const offFrom = parseInt($('offFrom').value) || -5;
  const offTo = parseInt($('offTo').value) || 5;

  showStatus('è¨ˆç®—ä¸­...');
  resultsEl.style.display = 'none';

  // Use setTimeout to allow UI to update
  setTimeout(() => {
    try {
      const t0 = performance.now();

      const wordSents = loadAndCollapse(loadedData);
      const nSents = wordSents.size;
      const nWords = [...wordSents.values()].reduce((s, ws) => s + ws.length, 0);

      const { surp, mc, V, T } = buildBigramModel(wordSents, alpha);
      const { allSurp, wordIndex, lookup } = computeAllSurprisals(wordSents, surp);

      const corpusMean = allSurp.reduce((a,b) => a+b, 0) / allSurp.length;
      const corpusSD = Math.sqrt(allSurp.reduce((s, v) => s + (v-corpusMean)**2, 0) / allSurp.length);

      const elapsed = ((performance.now() - t0) / 1000).toFixed(2);
      showStatus(`å®Œäº†ï¼ˆ${elapsed}sï¼‰`, 'ok');

      // Summary cards
      $('summaryCards').innerHTML = [
        { label: 'æ–‡æ•°', value: nSents },
        { label: 'èªãƒˆãƒ¼ã‚¯ãƒ³', value: nWords.toLocaleString() },
        { label: 'èªå½™ V', value: V },
        { label: 'SÌ„ corpus', value: corpusMean.toFixed(4) + ' bits' },
        { label: 'SD', value: corpusSD.toFixed(4) },
        { label: 'Î±', value: alpha },
      ].map(c => `<div class="stat-card"><div class="label">${c.label}</div><div class="value">${c.value}</div></div>`).join('');

      // Per target
      let html = '';
      const nComp = targetNames.length;
      const defaultColors = ['var(--red)', 'var(--blu)', 'var(--pur)', 'var(--grn)', 'var(--gld)'];
      const allChartSeries = []; // for overlay chart

      for (let ti = 0; ti < targetNames.length; ti++) {
        const name = targetNames[ti];
        const locs = findTargets(wordIndex, name);
        const color = name === 'mmja' ? 'var(--red)' : name === 'unu' ? 'var(--blu)' :
                      name === 'naugara' ? 'var(--pur)' : defaultColors[ti % defaultColors.length];

        html += `<div class="target-section">`;
        html += `<div class="target-header">
          <span class="target-name" style="color:${color}">${name}</span>
          <span class="target-meta">n = ${locs.length}</span>
        </div>`;

        if (!locs.length) {
          html += `<p style="color:var(--dim);font-size:13px;">ï¼ˆã‚³ãƒ¼ãƒ‘ã‚¹ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼‰</p></div>`;
          continue;
        }

        html += `<table><thead><tr>
          <th>Offset</th><th class="r">SÌ„</th><th class="r">n</th>
          <th class="r">d</th><th class="r">p (Bonf)</th>
        </tr></thead><tbody>`;

        const chartData = [];

        for (let off = offFrom; off <= offTo; off++) {
          const vals = getOffsetValues(locs, off, allSurp, lookup);
          if (!vals.length) continue;

          const mean = vals.reduce((a,b) => a+b, 0) / vals.length;
          const d = (mean - corpusMean) / corpusSD;
          chartData.push({ off, mean, n: vals.length });

          let pStr = '';
          if ([-1, 0, 1].includes(off) && vals.length >= 10) {
            const test = wilcoxonTest(vals, corpusMean);
            if (test.p !== null) {
              const pBonf = Math.min(test.p * nComp, 1);
              pStr = pBonf < 0.0001 ? `<span class="sig">&lt;.0001 <span style="font-size:10px;color:var(--dim)">(k=${nComp})</span></span>` :
                     pBonf < 0.05 ? `<span class="sig">${pBonf.toFixed(4)} <span style="font-size:10px;color:var(--dim)">(k=${nComp})</span></span>` :
                     `<span class="ns">${pBonf.toFixed(4)} <span style="font-size:10px;color:var(--dim)">(k=${nComp})</span></span>`;
            }
          }

          const label = off === -1 ? 'pre' : off === 0 ? 'self' : off === 1 ? 'post' : `${off > 0 ? '+' : ''}${off}`;
          const isKey = [-1, 0, 1].includes(off);
          const dClass = d > 0.2 ? 'pos' : d < -0.2 ? 'neg' : '';

          html += `<tr${isKey ? ' class="hl"' : ''}>
            <td>${label}</td>
            <td class="r">${mean.toFixed(4)}</td>
            <td class="r">${vals.length}</td>
            <td class="r ${dClass}">${d >= 0 ? '+' : ''}${d.toFixed(4)}</td>
            <td class="r">${pStr}</td>
          </tr>`;
        }

        html += `</tbody></table>`;

        // SVG chart
        if (chartData.length > 1) {
          html += renderChart(chartData, corpusMean, color, name);
          allChartSeries.push({ name, color, data: chartData, n: locs.length });
        }

        html += `</div>`;
      }

      // â”€â”€ Overlay chart (2+ targets) â”€â”€
      if (allChartSeries.length >= 2) {
        html += renderOverlayChart(allChartSeries, corpusMean);
      }

      $('targetResults').innerHTML = html;
      resultsEl.style.display = 'block';

    } catch (err) {
      showStatus('Error: ' + err.message, 'error');
      console.error(err);
    }
  }, 50);
}

function renderChart(data, corpusMean, color, name) {
  const W = 600, H = 160, pad = { t: 20, r: 50, b: 30, l: 50 };
  const plotW = W - pad.l - pad.r;
  const plotH = H - pad.t - pad.b;

  const allVals = data.map(d => d.mean).concat([corpusMean]);
  const yMin = Math.floor(Math.min(...allVals) - 0.5);
  const yMax = Math.ceil(Math.max(...allVals) + 0.5);

  const xScale = (off) => {
    const offsets = data.map(d => d.off);
    const minOff = Math.min(...offsets), maxOff = Math.max(...offsets);
    return pad.l + ((off - minOff) / (maxOff - minOff)) * plotW;
  };
  const yScale = (v) => pad.t + (1 - (v - yMin) / (yMax - yMin)) * plotH;

  const points = data.map(d => `${xScale(d.off).toFixed(1)},${yScale(d.mean).toFixed(1)}`).join(' ');
  const corpusY = yScale(corpusMean).toFixed(1);

  // Y axis ticks
  let yTicks = '';
  for (let v = Math.ceil(yMin); v <= Math.floor(yMax); v++) {
    const y = yScale(v).toFixed(1);
    yTicks += `<line x1="${pad.l}" y1="${y}" x2="${W-pad.r}" y2="${y}" stroke="var(--bdr2)" stroke-width=".5"/>`;
    yTicks += `<text x="${pad.l-6}" y="${y}" dy="3.5" text-anchor="end" fill="var(--dim)" font-size="10" font-family="var(--mono)">${v}</text>`;
  }

  // X axis labels
  let xLabels = '';
  for (const d of data) {
    const x = xScale(d.off).toFixed(1);
    const label = d.off === -1 ? 'pre' : d.off === 0 ? 'self' : d.off === 1 ? 'post' : `${d.off > 0 ? '+' : ''}${d.off}`;
    xLabels += `<text x="${x}" y="${H - pad.b + 16}" text-anchor="middle" fill="var(--dim)" font-size="9" font-family="var(--mono)">${label}</text>`;
  }

  // Dots
  let dots = '';
  for (const d of data) {
    const x = xScale(d.off).toFixed(1);
    const y = yScale(d.mean).toFixed(1);
    const r = [-1,0,1].includes(d.off) ? 4 : 2.5;
    dots += `<circle cx="${x}" cy="${y}" r="${r}" fill="${color}" opacity=".9"/>`;
    if ([-1,0,1].includes(d.off)) {
      dots += `<text x="${x}" y="${parseFloat(y)-8}" text-anchor="middle" fill="${color}" font-size="9" font-family="var(--mono)" font-weight="600">${d.mean.toFixed(2)}</text>`;
    }
  }

  return `
  <div class="chart-wrap">
    <h3>${name} â€” ã‚ªãƒ•ã‚»ãƒƒãƒˆåˆ¥ SÌ„</h3>
    <svg viewBox="0 0 ${W} ${H}" width="100%" style="max-width:${W}px;">
      ${yTicks}
      <line x1="${pad.l}" y1="${pad.t}" x2="${pad.l}" y2="${H-pad.b}" stroke="var(--bdr)" stroke-width="1"/>
      <line x1="${pad.l}" y1="${H-pad.b}" x2="${W-pad.r}" y2="${H-pad.b}" stroke="var(--bdr)" stroke-width="1"/>
      <line x1="${pad.l}" y1="${corpusY}" x2="${W-pad.r}" y2="${corpusY}" stroke="var(--gld)" stroke-width=".8" stroke-dasharray="4,3"/>
      <text x="${W-pad.r+4}" y="${corpusY}" dy="3.5" fill="var(--gld)" font-size="9" font-family="var(--mono)">SÌ„=${corpusMean.toFixed(2)}</text>
      <polyline points="${points}" fill="none" stroke="${color}" stroke-width="2" stroke-linejoin="round"/>
      ${dots}
      ${xLabels}
    </svg>
  </div>`;
}
function renderOverlayChart(series, corpusMean) {
  const W = 700, H = 240, pad = { t: 24, r: 60, b: 34, l: 54 };
  const plotW = W - pad.l - pad.r;
  const plotH = H - pad.t - pad.b;
  const dashPatterns = ['', '6,3', '2,3', '8,2,2,2', '4,4'];

  // Compute shared scales from all series
  const allOffsets = new Set();
  let allVals = [corpusMean];
  for (const s of series) {
    for (const d of s.data) {
      allOffsets.add(d.off);
      allVals.push(d.mean);
    }
  }
  const offsets = [...allOffsets].sort((a,b) => a - b);
  const minOff = offsets[0], maxOff = offsets[offsets.length - 1];
  const yMin = Math.floor(Math.min(...allVals) - 0.5);
  const yMax = Math.ceil(Math.max(...allVals) + 0.5);

  const xScale = off => pad.l + ((off - minOff) / (maxOff - minOff || 1)) * plotW;
  const yScale = v => pad.t + (1 - (v - yMin) / (yMax - yMin)) * plotH;
  const corpusY = yScale(corpusMean).toFixed(1);

  // Grid
  let yTicks = '';
  for (let v = Math.ceil(yMin); v <= Math.floor(yMax); v++) {
    const y = yScale(v).toFixed(1);
    yTicks += `<line x1="${pad.l}" y1="${y}" x2="${W-pad.r}" y2="${y}" stroke="var(--bdr2)" stroke-width=".5"/>`;
    yTicks += `<text x="${pad.l-6}" y="${y}" dy="3.5" text-anchor="end" fill="var(--dim)" font-size="10" font-family="var(--mono)">${v}</text>`;
  }

  // X labels
  let xLabels = '';
  for (const off of offsets) {
    const x = xScale(off).toFixed(1);
    const label = off === -1 ? 'pre' : off === 0 ? 'self' : off === 1 ? 'post' : `${off > 0 ? '+' : ''}${off}`;
    xLabels += `<text x="${x}" y="${H - pad.b + 16}" text-anchor="middle" fill="var(--dim)" font-size="9" font-family="var(--mono)">${label}</text>`;
  }

  // Lines + dots per series
  let lines = '';
  for (let si = 0; si < series.length; si++) {
    const s = series[si];
    const dash = dashPatterns[si % dashPatterns.length];
    const sw = si === 0 ? 2.5 : 2;

    // Polyline
    const pts = s.data.map(d => `${xScale(d.off).toFixed(1)},${yScale(d.mean).toFixed(1)}`).join(' ');
    lines += `<polyline points="${pts}" fill="none" stroke="${s.color}" stroke-width="${sw}" stroke-linejoin="round"${dash ? ` stroke-dasharray="${dash}"` : ''}/>`;

    // Dots: key offsets only (pre/self/post)
    for (const d of s.data) {
      if (![-1, 0, 1].includes(d.off)) continue;
      const x = xScale(d.off).toFixed(1);
      const y = yScale(d.mean).toFixed(1);
      lines += `<circle cx="${x}" cy="${y}" r="3.5" fill="${s.color}" opacity=".9"/>`;
    }

    // Post label (value at post offset)
    const postPt = s.data.find(d => d.off === 1);
    if (postPt) {
      const px = xScale(1);
      const py = yScale(postPt.mean);
      // Stagger labels to reduce overlap
      const labelOff = 12 + si * 13;
      lines += `<text x="${(px + 10).toFixed(1)}" y="${(py - 4 + si * 2).toFixed(1)}" fill="${s.color}" font-size="9" font-family="var(--mono)" font-weight="600">${postPt.mean.toFixed(2)}</text>`;
    }
  }

  // Legend
  let legend = '';
  const legendY = 14;
  let legendX = pad.l + 4;
  for (let si = 0; si < series.length; si++) {
    const s = series[si];
    const dash = dashPatterns[si % dashPatterns.length];
    legend += `<line x1="${legendX}" y1="${legendY}" x2="${legendX + 20}" y2="${legendY}" stroke="${s.color}" stroke-width="2"${dash ? ` stroke-dasharray="${dash}"` : ''}/>`;
    legend += `<text x="${legendX + 24}" y="${legendY + 3.5}" fill="${s.color}" font-size="10" font-family="var(--sans)">${s.name} <tspan fill="var(--dim)" font-size="9">(n=${s.n})</tspan></text>`;
    legendX += 26 + (s.name.length + 6) * 7;
  }

  return `
  <div class="chart-wrap" style="margin-top:28px;border-color:var(--gld);border-width:1.5px;">
    <h3 style="font-size:14px;color:var(--fg);margin-bottom:14px;">ã‚ªãƒ•ã‚»ãƒƒãƒˆåˆ¥ SÌ„ â€” å…¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé‡ã­åˆã‚ã›</h3>
    <svg viewBox="0 0 ${W} ${H}" width="100%" style="max-width:${W}px;">
      ${yTicks}
      <line x1="${pad.l}" y1="${pad.t}" x2="${pad.l}" y2="${H-pad.b}" stroke="var(--bdr)" stroke-width="1"/>
      <line x1="${pad.l}" y1="${H-pad.b}" x2="${W-pad.r}" y2="${H-pad.b}" stroke="var(--bdr)" stroke-width="1"/>
      <line x1="${pad.l}" y1="${corpusY}" x2="${W-pad.r}" y2="${corpusY}" stroke="var(--gld)" stroke-width=".8" stroke-dasharray="4,3"/>
      <text x="${W-pad.r+4}" y="${corpusY}" dy="3.5" fill="var(--gld)" font-size="9" font-family="var(--mono)">SÌ„=${corpusMean.toFixed(2)}</text>
      ${lines}
      ${xLabels}
      ${legend}
    </svg>
  </div>`;
}

</script>
</body>
</html>
